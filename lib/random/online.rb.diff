--- online.orig.rb	2011-04-21 23:59:34.000000000 +0200
+++ online.rb	2011-04-22 01:38:00.000000000 +0200
@@ -31,12 +31,22 @@
       ).start(@host) { |h|
         response = h.get("#{script}?#{parameters}")
         if response.class == Net::HTTPOK
-          return response
+          return check_response(response)
         else
-          raise "An HTTP error occured."
+          handle_response_error(response)
         end
       }
     end
+    
+    protected
+    
+    def  check_response(response)
+      return response
+    end
+    
+    def  handle_response_error(response)         
+      raise "An HTTP error occured."
+    end
   end
   
   class RandomOrg < OnlineGenerator
@@ -44,26 +54,22 @@
       super("www.random.org")
     end
 
-    def randnum(num = 100, min = 1, max = 100)
-      if num < 0 || num > 10_000
-        raise RangeError, "Invalid amount: #{num}."
-      end
-      return [] if num == 0
-      if min < -1_000_000_000
-        raise RangeError, "Invalid minimum: #{min}."
-      end
-      if max > 1_000_000_000
-        raise RangeError, "Invalid maximum: #{max}."
-      end
-      if max <= min
-        raise RangeError, "Maximum has to be bigger than minimum."
-      end
+    def randnum(num = 100, min = 1, max = 100, args = {})
+      check_amount_requested(num)
+      check_min_max_range(min, max)
 
       parameters = "num=#{num}&min=#{min}&max=#{max}&col=#{num}"
-      response = get_response("/cgi-bin/randnum", parameters)
+      parameters << "&format=plain&base=10"
+      parameters << "&rnd=#{args[:rnd]}" if args[:rnd]
+      
+      response = get_response("/integers/", parameters)
       convert_result(response.body)
     end
+    alias :integers :randnum
 
+    ##
+    # Note: randbyte is deprecated, should use '/integers/' instead.
+    # Network load decrease if using hex format instead here?
     def randbyte(nbytes = 256)
       if nbytes < 0 || nbytes > 16_384
         raise RangeError, "Invalid amount: #{nbytes}."
@@ -74,6 +80,71 @@
       convert_result(response.body)
     end
 
+    def randseq(min = 1, max = 100, args = {})
+      check_min_max_range(min, max)
+      
+      parameters = "min=#{min}&max=#{max}&col=1"
+      parameters << "&format=plain" # TODO: No need for "&base=10" here?
+      parameters << "&rnd=#{args[:rnd]}" if args[:rnd]
+      
+      response = get_response("/sequences/", parameters)
+      convert_result(response.body)
+    end
+    alias :sequences :randseq
+
+
+    def randstring(num, len, args = {})
+      default_args = { 
+          :digits => :on, 
+          :upperalpha =>:on, 
+          :loweralpha =>:on,
+          :unique => :off,
+          # :rnd => :new
+        }
+      args = default_args.update(args)
+
+      check_amount_requested(num)
+      check_num_within(len, 1, 20, 'length')
+
+      parameters = "num=#{num}&len=#{len}&format=plain"
+      parameters << "&" << hash_args_to_params(args)
+      
+      response = get_response("/strings/", parameters)
+      response.body.split
+    end
+    alias :strings :randstring
+    
+
+    def quota(ip=nil)
+      parameters = "format=plain"
+      parameters += "&ip=#{ip}" if ip
+      response = get_response("/quota/", parameters)
+      convert_result(response.body).first
+    end
+    
+    protected
+    
+    def  check_response(response)
+      # RandomOrg returns 200 OK even for failures...
+      error = contains_error(response.body)
+      handle_response_error(response, error.to_s) if error
+      return response
+    end
+
+    def  handle_response_error(response, message = nil)
+      unless message then
+        # Check the response body for an error message.
+        error = contains_error(response.body)
+        message = error.to_s if error
+      end
+      message ||= "An HTTP error occured."
+      raise message
+    end
+    
+    def contains_error(body)
+      body.match(/error:.*/i)
+    end
+    
     private
 
     def convert_result(response)
@@ -83,6 +154,32 @@
       }
       result
     end
+    
+    
+    def hash_args_to_params(args)
+      args.collect{|k,v| "#{k}=#{v}"}.join('&')
+    end
+    
+    def check_amount_requested(num)
+      check_num_within(num, 1, 10_000, 'amount')
+    end
+    
+    def check_num_within(num, min, max, desc = "number")
+      raise RangeError, "Invalid #{desc}: #{num}." if num < min || num > max
+    end
+    
+    def check_min_max_range(min, max)
+      if min < -1_000_000_000
+        raise RangeError, "Invalid minimum: #{min}."
+      end
+      if max > 1_000_000_000
+        raise RangeError, "Invalid maximum: #{max}."
+      end
+      if max <= min
+        raise RangeError, "Maximum has to be bigger than minimum."
+      end
+    end
+    
   end
 
   class FourmiLab < OnlineGenerator
